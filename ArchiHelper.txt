################################################################################################################################
################################################################################################################################
################################################################################################################################

*1* - *exe létrehozása*
EXE előállítása (DosBox cmd-ben):

C:\> masm.exe program.asm,,,,
C:\> link.exe program.obj,,,,

################################################################################################################################
################################################################################################################################
################################################################################################################################

*2* - *program váz*
Alap program váz (utána egy üres sor!!):
!!! A program részek, amiknek ':' van a végén azok automatikusan lefutnak még ha nem is ugranak bele!!!
!!! Ha azt szeretnénk, hogy egy elágazás után vége legyen a programnak akkor meg kell hívni a "jmp Program_Vege" utasítást!!!
================================================================================================================================

Code	Segment
	assume CS:Code, DS:Data, SS:Stack

Start:
	mov	ax, Code
	mov	DS, AX
    ;{PROGRAM IDE KERÜL}

Program_Vege:
	mov ax, 4c00h
	int 21h

Code	Ends

Data	Segment

Data	Ends

Stack	Segment

Stack	Ends
	End	Start

================================================================================================================================

################################################################################################################################
################################################################################################################################
################################################################################################################################

*3* - *műveletek*
Műveletek:

################################################################################################################################

*3.1* - *mov*
mov:
	Egyik memória területről a másikba való másolás
	mov {HOVA}, {MIT}

================================================================================================================================
	
	mov ax, F0h ;ax == 11110000b
	mov al, 1 ;ax == 11110001b
	mov bx, ax ;bx == 11110001b
	mov al, 8 ;ax == 11111000b
	;ax == 11111000b
	;bx == 11110001b

================================================================================================================================

################################################################################################################################

*3.2* - *add*
add:
	Összeadás, olyan, mint a '+='
	add {MIHEZ}, {MIT}

	add bl, 2 -> bl += 2

################################################################################################################################

*3.3* - *sub*
sub:
	Kivonás, olyan, mint a '-='
	sub {MIBŐL}, {MIT}

	sub bl, 2 -> bl -= 2

################################################################################################################################

*3.4* - *cmp*
cmp:
	Összehasonlítás, igazából kivonás, de a változók értéke nem változik, beállítja a flagaket
	cmp ax, 5 -> ax - 5

	Flagek:
		C: Carry - 1-re áll, ha az aritmetikai művelet során átvitel vagy áthozat keletkezik, bitléptető és forgató utasítások során is használatba kerül

		P: Parity - 0 az értéke, ha páros, 1 ha páratlan

		Z: Zero - 1 az értéke, ha az eredmény 0

		S: Sign - negatív eredmény esetén 1 az értéke

		O: Overflow - egy matematikai művelet eredménye meghaladja a kiszabott tartományt, akkor 1-re áll

	
	Pl.:
	[CPZSO -> 00000] (flagek ábrázolása szemléltetésképpen)
	1,
		mov ax, 5
		cmp ax, 5 -> [CPZSO -> 00100]

	2,
		mov ax, 4
		cmp ax, 5 -> [CPZSO -> 11011]

################################################################################################################################

*3.5* - *jmp*
Az ugrás után az a kód a megadott kódrész után folytatódik tovább, nem ugrik vissza autómatikusan!

jmp:
	Feltétel nélküli ugrás, egy megadott kódrészhez ugrik

================================================================================================================================
		
		...
		jmp Fuggveny  ;--┐
		...		;|
				;|
				;|
	Fuggveny:	;<-------┘
		;{MŰVELETEK}

================================================================================================================================

	Lehet végtelen ciklust is létrehozni vele:
================================================================================================================================

	Ciklus:
	...
	;{VALAMI PROGRAM}
	...
	jmp Ciklus

================================================================================================================================

################################################################################################################################

*3.6* - *jz*
jz:
	Feltételes ugrás, akkor ugrik, ha a "zero" flag 1

	Megfelel az "==" vel

================================================================================================================================

	mov ax, 5
	cmp ax, 5
	jz Egyenlo
	...

Egyenlo:
	;{AKKOR FUT LE HA EGYENLŐ}

================================================================================================================================

	Fenti kódrész kb egyenlő ezzel:
================================================================================================================================

	ax = 5
	if (ax == 5){
		;{AKKOR FUT LE HA EGYENLŐ}
	}

================================================================================================================================

################################################################################################################################

*3.7* - *jnz*
jnz:
	Feltételes ugrás, akkor ugrik, ha a "zero" flag 0

	Megfelel az "!=" vel

================================================================================================================================

	mov ax, 6
	cmp ax, 5
	jnz NemEgyenlo

	...

NemEgyenlo:
	;{AKKOR FUT LE HA NEM EGYENLŐ}

================================================================================================================================

################################################################################################################################

*3.8* - *jc*
jc:
	Feltétel ugrás, akkor ugrik, ha a "carry" flag 1
	Pl.:

================================================================================================================================

	mov ax, 4
	cmp ax, 5 ;4-5 = -1, mivel az eredmény negatív nem lehet ezért átfordul és 255 lesz, ez triggereli a carry flaget
	jc VanCarry

	...

VanCarry:
	;{AKKOR FUT LE HA A "CARRY" FLAG 1}
	;{EZ AZT IS JELENTI HOGY A 4 KISEBB MINT AZ 5, HA ERRE VAGYUNK KÍVÁNCSIAK ILYEN MÓDON IS LEHET VIZSGÁLNI}

================================================================================================================================

################################################################################################################################

*3.9* - *jnc*
jnc:
	Feltétel ugrás, akkor ugrik, ha a "carry" flag 0
	Pl.:
================================================================================================================================

	mov ax, 6
	cmp ax, 5
	jnc NincsCarry

	...

NincsCarry:
	;{AKKOR FUT LE HA A "CARRY" FLAG 0}
	;{EZ AZT IS JELENTI HOGY A 6 NAGYOBB VAGY EGYENLŐ MINT AZ 5, HA ERRE VAGYUNK KÍVÁNCSIAK ILYEN MÓDON IS LEHET VIZSGÁLNI}

================================================================================================================================

################################################################################################################################

*3.10* - *többi jump*

stb... többi ugrás is hasonlóan működik csak más feltétellel rendelkeznek
Több kondícionális ugrásra példa és azok negáltjai:

JE/JNE = Equal, ez kb ugyan az, mint a JZ/JNZ
JO/JNO = Overflow
JS/JNS = Signed
JP/JNP, JPE/JPO = Parity, even(páros)/odd(páratlan). JP/JNP, JPE/JPO pár ugyan azt jelenti

################################################################################################################################

*3.11* - *loop*

Ciklusok megvalósításához használható, hasonló, mint a JMP utasítással létrehozott loop.
Különbség a kettő között az, hogy ha "loop" utasítást használunk akkor meg tudjuk könnyedén adni, hogy hányszor fusson le a ciklus.
Ciklus lefutásának a számát a "cx" regiszterben található érték befolyásolja. Minden egyes ciklus lefutás után ebből a regiszterből levonódik egy és ha ez eléri a 0-t akkor kilép a ciklusból.

Hasonló, mint C nyelvben a következő:
A példában a "cx" regisztert a counter reprezentálja.

================================================================================================================================

unsigned char counter = 5;

// Addig fut a while ciklus még a counter értéke 0 nem lesz. 0 = false.
while(counter--) {

	...

}

================================================================================================================================

Loop használata assemblyben:

================================================================================================================================

	mov cx, ;{AHÁNYSZOR SZERETNÉNK HOGY A CIKLUS LEFUSSON}

Valami:
	...
	loop Valami

================================================================================================================================

Példa:

10x írassuk ki az 'A' betűt:

================================================================================================================================

	...
	
	mov cx, 10 ;Számláló regiszter beállítása
	mov ah, 02

Kiirat:
	mov dl, 'A'
	int 21h

	loop Kiirat

	...

================================================================================================================================

################################################################################################################################

*3.12* - *offset*

Megadja az adott objektum címét.

Pl:
================================================================================================================================

...

mov dx, offset uzenet ;ekkor a "dx" az "uzenet" címére fog mutatni

;ekkor a "dx" értékét ha lekérjük akkor az a "v"-re fog mutatni az uzenetben
;Ezt az értéket a "[]" operátorral lehet lekérni. (3.13 - szögletes zárójel), ha csak magát a "dx"-et íratjuk ki akkor az adott memóriacímét fogkuk kiíratni.
;ha a "dx"-t incrementáljuk akkor már "a" lesz az értéke

...

uzenet db "valami$"

================================================================================================================================

Használható szövegek bejárására is. Például olyan feladatokhoz, hogy egy adott szövegben mennyi "x" betű van.

================================================================================================================================

	...

	mov cx, 0 ;"di" regiszterben fogjuk eltárolni hogy éppen hanyadik betűnél járunk
Vizsg:
	mov di, offset uzenet ;Beállítjuk a "di" regisztert hogy az a "uzenet" kezdetére mutasson 
	add di, cx ;"hozzáadjuk a mutatóhoz hogy hanyadik betűnél jártunk"

	mov al, 'e'	; \
	cmp [di], al;  > Megvizsgáljuk hogy az éppen kijelölt betű 'e'-e, ha igen ugrunk a "Novel" kódrészhez
	jz Novel	; /
	mov al, '$'		;\
	cmp [di], al	; > Megvizsgáljuk hogy a szöveg végéhez értünk e. Ha igen akkor elugrunk a program végéhez.
	jz Program_Vege	;/
	inc cx ;Növeljük a "cx" regiszter érétkét, ezzel egyel tovább haladunk a betűvizsgálatban
	jmp Vizsg ;Ha se nem 'e' se nem '$' akkor folytatjuk tovább a vizsgálatot

Novel:
	mov di, offset ertek	;\
	mov al, [di]			; \ Növeljük a számláló értékét 
	inc al					; /
	mov [di], al			;/
	inc cx ;Növeljük a betűszámláló értékét
	jmp Vizsg ;Visszaugrunk a vizsgálatba és folytatódik tovább a program

	...

================================================================================================================================

################################################################################################################################

*3.13* - *szögletes zárójel* - *[]*

Akkor használható, ha módosítani szeretnénk egy pointer azon értékét amelyre mutat.

Pl:
================================================================================================================================
	...

	mov di, offset ertek ;"di" eddig az a ra mutatott
	inc di ;"di" mostmár a b re mutat

	...

ertek db "ab$"

================================================================================================================================

Különbség "mov ax, 10" és "mov [ax], 10" között.

1, mov ax, 10

Ebben az esetben a 10 az "ax" regiszterbe kerül.

2, mov [ax], 10

Ebben az esetben a 10 oda kerül, ahova az "ax" pointer mutat. Itt az "ax" csak egy mutató egy cím felé.

################################################################################################################################

*3.14* - *push/pop*

Ezzel a két művelettel lehet regiszterek értékét a verembe(stack)-be mozgatni, illetve kiszedni azokat onnan egy megadott regiszterbe.

!!! A verembe mozgatott érték regiszterének az értéke nem fog változni mozgatás után !!!
!!! A verembe csakis teljes regisztereket lehet mozgatni, nem lehet külön az "xl" vagy a "xh" regisztereket
!!! A verem LIFO elven működik, ez azt jelenti hogy azt pop oljuk amit utoljára pusholtunk !!!
!!! Ha pop olunk akkor a popolt érték felülírja a megadott regiszter tartalmát !!!

Pl.:
================================================================================================================================

	...

	mov dl, 1
	push dx

	mov ah, 02h
	int 21h			; "dl" értéke még mindig 1 annak ellenére, hogy a verembe mozgattuk az értékét
					; veremben eltároltuk a "dx" értékét
	...

================================================================================================================================

Akkor hasznos, ha pl. valamilyen utasítást akarunk elvégezni, de a számunkra fontos eredmény értéke abban a regiszterben található ahová az utasítás paramétereit kell mozgatni.

Pl.: Szorzás eredményét, és egy másik regiszter eredményét el szeretnénk tárolni, úgy, hogy a kiíratásuk között egy másik karaktert is ki szeretnénk íratni.
================================================================================================================================

	mov ax, 2
	mov dx, 4
	mul dx

	mov dx, 6

	push ax ; szorzás eredményét bemozgattuk a verembe
	push dx ; másik számot is bemozgattuk a verembe

	mov ah, 02h
	mov dl, 'A'
	int 21h

	pop dx ; LIFO elven működnek a vermek
	add dl, '0'
	int 21h

	pop dx
	add dl, '0'
	int 21h

================================================================================================================================

################################################################################################################################

*3.15* - *mul*

Szorzás. 2 regiszter értékét összeszorozza.

!!! Ha 2 16-bites szám szorzása az alábbi példa alapján nagyobb számot eredményezne akkor a szám alsó 16 bitje az "ax" regiszterben lesz megtalálható a felső része a "dx" regiszterben

16-bites számok szorzása:
================================================================================================================================

	...

	mov ax, 5
	mov dx, 10
	mul dx ; ax = ax * dx -> ax = 50

	mov cx, 2
	mul cx ; ax = ax * cx -> cx = 100

	...

================================================================================================================================

!!! Ha 8 bitnél nagyobb lesz a szám akkor az "ah" és az "al" ben fog eltárolódni a szám.

8-bites számok szorzása:
================================================================================================================================

	mov al, 2
	mov dl, 2
	mul dl ; al = al * dl

================================================================================================================================

################################################################################################################################

*3.16* - *div*

Osztás.

16-bites szám osztása 8-bites számmal ("al" regiszterben fog eltárolódni az osztás egész értéke, "ah" reg.-ben pedig az osztás maradéka):
================================================================================================================================

	mov ax, 16
	mov dl, 8
	div dl ; al = ax / dl -> al = 2

================================================================================================================================


16-bites szám osztása 8-bites számmal, maradékkal 
================================================================================================================================

	mov ax, 16
	mov dl, 7
	div dl ; al = (ax / dl) -> al = 2, ah = 2

================================================================================================================================

################################################################################################################################
################################################################################################################################
################################################################################################################################

*4* - *bináris műveletek*
Bináris műveletek:

################################################################################################################################

*4.1* - *and*
and:
	Logikai "és" művelet, olyan, mint az "&="
	and {MIT}, {MIVEL}

	Pl.:
================================================================================================================================

	mov ax, 0Fh
	and ax, 3 ;ax &= 3 -> ax == 03h

================================================================================================================================
	
	ax:  0 | 0 | 0 | 0 | 1 | 1 | 1 | 1
	3:   0 | 0 | 0 | 0 | 0 | 0 | 1 | 1
	----------------------------------
	and: 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1

################################################################################################################################

*4.2* - *or*
or:
	Logikai "vagy" művelet, olyan, mint az "|="
	or {MIT}, {MIVEL}

	Pl.:
================================================================================================================================

	mov ax, 0Fh
	or ax, 41h ;ax &= 41h -> ax == 4Fh

================================================================================================================================
	
	ax: 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1
	65: 0 | 1 | 0 | 0 | 0 | 0 | 0 | 1
	---------------------------------
	or: 0 | 1 | 0 | 0 | 1 | 1 | 1 | 1

################################################################################################################################

*4.3* - *xor*
xor:
	Logikai "kizáró vagy" művelet, olyan, mint az "^="
	xor {MIT}, {MIVEL}

	Pl.:
================================================================================================================================

	mov ax, 0Fh
	xor ax, 41h ;ax ^= 41h -> ax == 4Eh

================================================================================================================================

	
	ax:  0 | 0 | 0 | 0 | 1 | 1 | 1 | 1
	65:  0 | 1 | 0 | 0 | 0 | 0 | 0 | 1
	----------------------------------
	xor: 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0

################################################################################################################################

Léptetéseknél, ha 1-nél nagyobb számmal szeretnénk léptetni akkor a léptetés méretét a "cl"-regiszterbe kell írni

*4.4* - *shl*
shl:
	Bitléptetés balra, olyan, mint az "<<=" 

	shl {MIT}, {MENNYIVEL}

	Pl.:
================================================================================================================================

	mov ax, 0Fh
	mov cl, 4
	shl ax, cl ;ax <<= 4 -> ax == F0h

================================================================================================================================

	
	       ax: 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1
	----------------------------------------
	shl ax, 4: 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0

	Ha kimozgatjuk az értéket akkor nem fog körbefordulni:

================================================================================================================================

	mov ax, 80h
	shl ax, 1 ;ax == 0

================================================================================================================================

################################################################################################################################

*4.5* - *shr*
shr:
	Bitléptetés jobbra, olyan, mint az ">>=" 

	shr {MIT}, {MENNYIVEL}

	Pl.:
================================================================================================================================

	mov ax, 0Fh
	mov cl, 2
	shr ax, cl ;ax >>= 4 -> ax == 03h

================================================================================================================================

	
	       ax: 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1
	----------------------------------------
	shr ax, 2: 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1

	Ha kimozgatjuk az értéket akkor nem fog körbefordulni:

================================================================================================================================

	mov ax, 0Fh
	shr ax, 1 ;ax == 7

================================================================================================================================

################################################################################################################################

*4.6* - *rol*
rol:
	Bitléptetés körbefordulással
	rol {MIT}, {MENNYIVEL}

	Pl.:
================================================================================================================================

	mov ax, F0h
	rol ax, 1; ax == E1h

================================================================================================================================

	       ax: 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0
	----------------------------------------
	rol ax, 1: 1 | 1 | 1 | 0 | 0 | 0 | 0 | 1

################################################################################################################################

*4.7* - *ror*
ror:
	Bitléptetés körbefordulással
	ror {MIT}, {MENNYIVEL}

	Pl.:
================================================================================================================================

	mov ax, 0Fh
	ror ax, 1; ax == 87h

================================================================================================================================	

	       ax: 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1
	----------------------------------------
	ror ax, 1: 1 | 0 | 0 | 0 | 0 | 1 | 1 | 1

################################################################################################################################
################################################################################################################################
################################################################################################################################

*5* - *konzol kezelés*
Különféle megjelenítéssel és adat bevitellel kapcsolatos utasítások.

################################################################################################################################

*5.1* - *képernyő törlés*
Hasonló eredménye van, mint a "Console.Clear()"-nek.

!!! Ha utána akarunk kiíratni karaktert akkor újra meg kell hívni a "mov ah, 02"-t nem lehet úgy csinálni mint amikor több karaktert írunk ki egymás után !!!

================================================================================================================================	

mov ax, 03h
int 10h

================================================================================================================================

################################################################################################################################

*5.2* - *kurzor pozícionálása*
Hasonló, mint a "Console.SetCursorPosition(x, y)"

================================================================================================================================

mov ah, 02h
mov bh, 0
mov dh, ;{SOR SZÁMA} ;Hanyadik sorba íródjon ki a karakter
mov dl, ;{OSZLOP SZÁMA} ; Hanyadik oszlopba íródjon ki a karakter
int 10h

================================================================================================================================

################################################################################################################################

*5.3* - *karakter bevitel*
A beütött karaktert az "al" regiszter tárolja le!

================================================================================================================================

xor ax, ax
int 16h

================================================================================================================================

################################################################################################################################

*5.4* - *karakter kiíratás*
Karakter kiíratása:

================================================================================================================================

mov ah, 02
mov dl, ;{KARAKTER KÓD}
int 21h

================================================================================================================================

Karakter kódok a következők lehetnek:
ASCII kódok alapján kell megadni a karaktereket.
Pl.: '0' karakter megadása:
'0' karakter kódja 48

1, decimálisan megadva:
	mov dl, 48

2, hexadecimálisan:
	mov dl, 30h

3, binárisan:
	mov dl, 00110000b

4, karakter megadásával:
	mov dl, '0'


Karakterek megadása műveletekkel:

Pl. '2' megadása:

================================================================================================================================

mov bl, '0' ;megadjuk a '0'-t mint kezdő karakter
add bl, 2 ;hozzáadjuk a kívánt számot

mov ah, 02h
mov dl, bl ;2 kerül kiíratásra
int 21h

================================================================================================================================

################################################################################################################################

*5.5* - *szöveg kiíratás*
Szöveg kiíratása:

================================================================================================================================

mov dx, offset uzenet
mov ah, 09h
int 21h

Program_Vége:
	...

; $ jel kell a szöveg végére, eddig írja ki a program a szöveget
; pl.: "Ez egy$uzenet" -> 'Ez egy'

uzenet db "Ez egy uzenet!$"

================================================================================================================================

################################################################################################################################

*5.6* - *karakterre várás program feltartása nélkül*

Ebben a módban a program úgy képes bekérni karaktereket a felhasználótól, hogy közben bármi egyebet is tud csinálni.
Pl: karakterek folyamatos kiíratás úgy, hogy a kiírt karaktert anélkül tudjuk megadni hogy a program a karakterek kiírását abbahagyja

================================================================================================================================

mov cl, ' '				; Kezdeti karakter egy space, eleinte ezt fogja csak kiírni
Ciklus:
	mov ah, 02h			;\
	mov dl, cl			; | Elmentett karakter kiíratása
	int 21h				;/
	mov ah, 01h			;\
	int 16h				; | Vizsgálja, hogy a key bufferben vannak e karakterek, ha igen a zero flag 1 re áll
	jnz KarakterMent	;/
	jmp Ciklus

KarakterMent:
	mov ah, 00h			;\ A bufferből kivesszük a karaktert, belekerül az "al" regiszterbe
	int 16h				;/

	cmp al, 27			;\ ha ez a karakter egy esc akkor a program nem fut le tovább
	jz Program_Vege		;/

	mov cl, al			;\ Karakter mentése a "cl" regiszterbe, visszalépés a fő ciklusba
	jmp Ciklus			;/

================================================================================================================================

################################################################################################################################
################################################################################################################################
################################################################################################################################

*6* - *számlálás*
Egy "db"-ben eltárolt karakter növelése.
Pl.: ha egy szöveg a következő "0$" ha ezt megnöveljük akkor "1$" lesz

Ha egy szövegen belül több karakter van akkor mindig a legelső (a legbalrább) lévő karakter fog növekedni, kivéve ha a "di értékét módosítjuk.

================================================================================================================================

mov di, offset ;{NÖVELENDŐ SZÖVEG}
mov al, [di]
inc al ;ha pl 2-vel szeretnénk növelni a karaktert akkor ennek a sor helyére kerülhet pl hogy "add al, 2"
mov [di], al

================================================================================================================================

Példa számlálás 9-nél nagyobb számokkal:

================================================================================================================================
	...

	ertek db "00$"

	...

	mov cx, 90; ;Loop beállítása
Novel:
	mov dx, offset ertek ; \
	mov ah, 09			 ;  \
	int 21h				 ;   \
	mov ah, 02			 ;    > Kiíratás
	mov dl, ' '			 ;   /
	int 21h				 ;  /

	mov di, offset ertek	; \
	inc di					;  \
	mov al, [di]			;   > Érték második karakterjének a léptetése
	inc al					;  /
	mov [di], al			; /

	mov ah, '9'				;\ Ha a második karakter 9 és növelni szeretnénk akkor az első karakter értéke növelődik 1-el
	cmp ah, al				;/ 
	js Leptet
	loop Novel				;Loop vissza a "Novel" kódrész kezdetéhez
	jmp Program_Vege		;Loop után vége a programnak
	
Leptet:
	mov di, offset ertek	;\
	mov al, [di]			; > Első karakter megnövelése
	inc al					;/
	
	mov [di], al			;\
	inc di					; \
	mov al, [di]			;  > Második karakterből kivonunk 10-et, ezzel visszaállítva annak az értékét '0'-ra
	sub al, 10				; /
	mov [di], al			;/
	
	jmp Novel				; Visszaugrás a "Novel" kódrészhez

	...

================================================================================================================================

################################################################################################################################
################################################################################################################################
################################################################################################################################

*7* - *időzítők*

################################################################################################################################

*7.1* - *óra beolvasása*

A gép órájának az értékét tick-ben beletölti a "CX:DX" regiszterekbe

1 tick ≈ 0,0549 mp
1 mp ≈ 18.2 tick (18)
1 perc ≈ 1092 tick
1 óra ≈ 65543
1 nap ≈ 1573040

================================================================================================================================

	xor ah, ah ;\ 
	int 1ah    ;/ Óra bekerül a "CX:DX" regiszterbe

================================================================================================================================

################################################################################################################################

*7.2* - *eltelt idő számítása*

Eltelt időt 2 időpont különbségével tudjuk számolni

================================================================================================================================

	xor ah, ah
	int 1ah
	mov bx, dx

	...

	xor ah, ah
	int 1ah

	sub dx, bx ; "dx" regiszter eredménye az eltelt tickek száma

================================================================================================================================

################################################################################################################################
################################################################################################################################
################################################################################################################################

*8* - *egyéb műveletek*

################################################################################################################################

*8.1* - *paraméterek kezelése*

Paraméterek azok a dolgok, amelyek program elindítása után a futtatható tartomány után írunk.

!!! Figyelni kell, hogy a "start" részébe a programnak "mov	di, 81h"-t kell írni. majd ha végeztünk a paraméter vizsgálattal vissza kell ezt állítani az alapértelmezettre. !!!

Pl:
================================================================================================================================

program.exe {VALAMILYEN PARAMÉTER}

================================================================================================================================

A beolvasott paraméterek a "di" regiszterben tárolódnak el.
A ennek a karaktersorozatnak az utolsó karaktere egy "0Dh", ezt lehet arra használni hogy kiderítsük hogy a beolvasott paraméterek végére értünk-e.

Paraméterek vizsgálata, pl: '/' jel után megadott karakter kiolvasása:
================================================================================================================================


Code	Segment
	assume CS:Code, DS:Data, SS:Stack

Start:
	mov di, 81h ;Paraméterkeresés indítása

Keres:
	mov dl, [di]
	cmp dl, '/'
	jz ParamKezel
	cmp dl, 0Dh
	jz NincsParam
	inc di
	jmp Keres

ParamKezel:
	;dl eltárolta a paraméter értékét
	inc di
	mov dl, [di]
	mov ah, 02h
	int 21h
	jmp Init

NincsParam:
	mov ax, Code
	mov DS, AX
	mov dx, offset nincs
	mov ah, 09h
	int 21h
	jmp Program_Vege

Init:
	mov	ax, Code ;Alapértelmezett beállítások visszaállítása paraméter kezelés után
	mov	DS, AX

...

nincs db "Nincs parameter!$"

================================================================================================================================

################################################################################################################################

*8.2* *bináris szám decimálissá alakítása* !

Osztáson alapul a folyamat.

Osztásnál az "ax"-regisztert osztjuk a megadott másik regiszterrel.

Az eredmény egész része az "al"-ban fog eltárolódni, az osztás maradéka pedig az "ah"-ba kerül.

Majd kiíratjuk/eltároljuk az "al"-t és tovább dolgozunk a maradékkal. 

Pl:
================================================================================================================================
	
	...
	
	mov ax, 153 ; alap értéked amit ki szeretnénk íratni
	mov dl, 100 ; 100-al fogjuk elosztani ax-t
	div dl ;ax -> [1|53]

	push ax

	mov dl, al ; kiíratjuk az 1-et
	add dl, '0'
	mov ah, 02h
	int 21h

	pop ax

	mov al, ah ;\ ax értékét a maradékra állítjuk
	xor ah, ah ;/

	mov dl, 10
	div dl ; ax -> [5|3]

	;kiíratás
	push ax
	mov ah, 02h
	mov dl, al
	add dl, '0'
	int 21h

	pop ax
	mov dl, ah
	mov ah, 02h
	add dl, '0'
	int 21h

	; működése:
	; ax értéke 153
	; ax/100 -> 1 | 53 maradék
	; eredmény kiíratása
	; maradék / 10 -> 5 | 3 maradék
	; eredmény kiíratása
	; maradék kiíratása

	...

================================================================================================================================

################################################################################################################################
################################################################################################################################
################################################################################################################################

*9* *grafikus műveletek*

Grafikus módban a munkaterünk 320x200-as. Az indexelés a bal felső saroktól kezdődik, ennek az értéke [0;0], első sor utolsó értéke 319.
Az egyes pixelek helye, színe az ES:DI regiszterekben vannak eltárolva.
256 különböző szín lehetséges.
A pixelek értékei folyamatosan vannak eltárolva, ez azt jelenti, hogy a 320. érték a második sor első pixelét jelenti már.

Kezdő pixel értékét így lehet megadni: y*320+x

Ha az X koordinátát szeretnénk módosítani akkor a "di" regiszter értékét vagy csökkentjük, vagy növeljük 1-el.
Ha az Y koordinátát szeretnénk módosítani akkor a "di" regiszter értékét vagy csökkentjük, vagy növeljük 320-al.

################################################################################################################################

*9.1* *grafikus módba váltás*

!!! Ha grafikus módba váltunk akkor utána mielőtt vége lesz a programunknak vissza kell lépni karakteres módba !!!

================================================================================================================================

	...

	mov ax, 13h ;\ Grafikus módba váltunk.
	int 10h		;/

	...

Program_Vege:
	; Karakteres módba visszaváltunk
	mov ax, 03h
	int 10h

	...

================================================================================================================================

Képernyő törlése grafikus módban, is hasonló módon történik:

================================================================================================================================

	...

	mov ax, 13h
	int 10h

	...

================================================================================================================================


################################################################################################################################

*9.2* *pixel rajzolása*

================================================================================================================================

	...

	mov ax, 13h
	int 10h
	mov ax, 0A000h
	mov es, ax
	
	; x = 20
	; y = 50
	mov ax, 50 ;Y koordináta
	mov bx, 320
	mul bx ; DX:AX = Y * 320
	add ax, 20 ; x koordináta, ax = y*320+x
	mov di, ax

	mov al, 129 ; szín 129-es a palettából
	mov es:[di], al
	
	...

================================================================================================================================

################################################################################################################################

*9.3* *pixel színe*

================================================================================================================================

	mov al, 129 ; "al"-regiszter értékével lehet megadni a színeket
	mov es:[di], al

================================================================================================================================

Színek:
A README.md fileban található táblázat alapján meg kell adni egy számot.

################################################################################################################################

*9.4* *vonalak húzása*

"di"-regiszter értékének a változtatásával lehet a pixel pozícióját mozgatni.
A "cx"-regiszter értéke lesz a vonal hossza.

================================================================================================================================

	...

	mov cx, 256
Loop:
	mov al, 80
	mov es:[di], al
	inc di
	loop Loop

	...

================================================================================================================================

Vonalak iránya:

jobbra:
	inc di

balra:
	dec di

fel:
	sub di, 320 

le:
	add di, 320

45°:
balról jobbra, felfelé:
	sub di, 319

jobbról balra, felfelé:
	sub di, 321

balról jobbra, lefelé:
	add di, 321

jobbról balra, lefelé:
	add di, 319

################################################################################################################################

*9.5* *alakzatok kitöltése*

Ez végül is több vonal egymás körül. 20x15 téglalap: 20db 15 hosszúságú vonal.

Téglalap:
================================================================================================================================

	...

	mov cx, 50
	mov al, 15
Magassag:
	push cx
	mov cx, 120
Oldal:
	mov es:[di], al
	inc di
loop Oldal
	pop cx
	add di, 200
loop Magassag

	....

================================================================================================================================

Háromszög:
================================================================================================================================

	...

	mov cx, 50
	mov al, 15
Magassag:
	mov dx, cx
	push cx
	mov cx, 51
	sub cx, dx
Oldal:
	mov es:[di], al
	inc di
loop Oldal
	pop cx
	add di, 269
	add di, dx
loop Magassag

	...

================================================================================================================================

================================================================================================================================

	...

	mov dx, 1
	mov cx, 50
Cuccos:
	push cx
	mov cx, dx
	Cuccos2:
		inc di
		mov es:[di], al
loop Cuccos2
	pop cx
	add di, 320
	sub di, dx
	inc dx
loop Cuccos

	...

================================================================================================================================

Rombusz:
================================================================================================================================

	...
	
	mov ax, 0A000h
	mov es, ax

	mov ax, 13h
	int 10h 

	mov ax, 50
	mov dx, 320
	mul dx
	add ax, 160
	mov di, ax
	mov al, 15

	mov dx, 1
	mov cx, 51
Cuccos:
	push cx
	mov cx, dx
	Cuccos2:
		inc di
		mov es:[di], al
	loop Cuccos2
	pop cx
	add di, 320
	cmp cx, 27

jc Add
	sub di, dx
	sub di, 1
	add dx, 2
	loop Cuccos


Add:
	sub di, dx
	add di, 1
	sub dx, 2
	loop Cuccos


Program_Vege:
	xor ax, ax
	int 16h
	mov ax, 02h
	int 10h 

	...

================================================================================================================================

################################################################################################################################

*9.6* *grafikus módban billentyű leütések észlelése*

Pontosan ugyan úgy történik, mint karakteres módban, viszont figyelni kell rá, hogy egyes karakterek észleléséhez azoknak a "scancode"-ját kell használnunk, ezek is ugyan úgy megtalálhatóak a helper programban.

################################################################################################################################
################################################################################################################################
################################################################################################################################

*10* *függvények*

Hasonlóak, mint a ":"-al ellátott kódrészek, viszont itt vissza is ugrunk oda, ahol eddig a kód tartott.
Értékeket átadni, regiszterek segítségével lehet legegyszerűbben.

Függvény meghívása, és deklarálása:
================================================================================================================================

	...

	call Fuggveny
	;következő utasítás ami a függvény lefutása után fog lefutni. A program halad tovább innentől.
	...

;ad az "ax"-regiszterhez 2-t, majd kiírja az értékét
Fuggveny:
	push dx ;"dx"-regiszter érzékét stackbe elmentjük mivel nem szeretnénk hogy ennek az értéke módosuljon függvény lefutásakor.
	add ax, 2
	push ax
	mov ah, 02h
	mov dx, ax
	int 21h

	pop ax
	pop dx
	ret ;visszatér a "call Fuggveny" sor utáni utasításra és folytatódik tovább a program

	...

================================================================================================================================

################################################################################################################################
################################################################################################################################
################################################################################################################################
